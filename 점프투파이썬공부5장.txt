점프투파이썬공부5장

[5-1] 클래스

-클래스는 왜 필요한가?

# 계산기가 두 대 필요한 프로그램: 각각의 계산기에 서로 다른 내용이 저장되어야함.
같은 내용의 함수와 전역변수가 여러 개 필요 -> 코드가 길어진다.

# 클래스를 사용하기
각각의 객체는 서로 독립적인 값을 유지한다.
계산기 대 수가 늘어나도 객체만 생성하면 됨. -> 간편해짐 


-클래스와 객체

클래스 - 똑같은 무엇인가를 계속해서 만들어낼 수 있는 틀.
객체 - 클래스로 만든 피조물. 하지만 객체마다 고유한 성격을 가진다. 독립적이다.

# ex 쿠키 클래스와 a, b 객체
>>> class Cookie:
...     pass
...
>>>a=Cookie()
>>> b=Cookie()

**객체와 인스턴스 차이
'a는 Cookie의 인스턴스' 'a는 객체'
인스턴스-클래스와 객체 사이의 관계를 나타낼 때
객체-독립된 a를 말할 때.



-사칙연산 클래스 만들기


1. 클래스 구조 만들기

# type 함수는 객체 타입을 출력한다.
>>> class Fourcal:
...     pass
...
>>> a=Fourcal()
>>> type(a)
<class '__main__.Fourcal'>


2. 객체에 숫자 지정할 수 있게 만들기

>>> class Fourcal:
...     def setdata(self, first, second):
...             self.first = first
...             self.second = second

클래스 안에 구현한 함수: 메서드
객체를 통해 클래스의 메서드 호출하기: a.setdata(3,4)
(self, first, second)에서 self의 의미: a객체 자신 

**또 다른 메서드 호출법
#클래스를 통해 메서드 호출
>>> a = FourCal()
>>> FourCal.setdata(a, 4, 2) # 반드시 a를 써야함.
# 일반적으로는 a.setdata(3,4)



# setdata() 수행문

self.first = 4
self.second = 2

a.first = 4 # a객체에 객체변수 first가 생성되고 값 4가 저장된다.
a.second = 2


-더하기 기능 만들기
>>> class Fourcal:
...     def setdata(self, first, second):
...             self.first = first
...             self.second = second
...     def add(self):
...             result = self.first+self.second
...             return result
...
>>> a=Fourcal()
>>> a.setdata(4,2)
>>> print(a.add())

#a.add() - > add메서드가 수행되면 self에는 자동으로 객체 a가 입력된다.


-생성자(Constructor)
# __init__

>>> class FourCal:
...     def __init__(self, first, second):
...             self.first = first
...             self.second = second
...     def setdata(self, first, second):
...             self.first = first
...             self.second = second
...     def add(self):
...             result = self.first+self.second
...             return result
...     def mul(self):
...             result = self.first-self.second
...             return result
...     def div(self):
...             result = self.first/self.second
...             return result
...
>>> a=FourCal(3,4) # 반드시 생성자의 형태로 매개변수를 설정해야한다.

>>> a.add()
7
>>> a.mul()
-1
>>> a.div()
0.75


-클래스의 상속
기존 클래스는 놔둔 채 새로운 클래스를 만들어 기능 확장.

어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만든다.
** class 클래스이름(상속받을 클래스이름) **

>>> class MoreFourCal(FourCal):
...     def pow(self):
...             result = self.first ** self.second #제곱 형태 
...             return result
...
>>> a = MoreFourCal(4,2)
>>> a.pow()
16

->> 기존 클래스에 기능을 추가하거나 변경할 때 사용.
기존 클래스가 수정이 허용되지 않을 떄 상속을 사용.



-메서드 오버라이딩
부모클래스에 있는 메서드를 동일한 이름으로 다시 만드는 것.
부모클래스의 메서드 대신 오버라이딩한 메서드가 호출된다.

# 0이 분모가 되면 에러가 나기 때문에.
>>> class safeFourCal(FourCal):
...     def div(self):
...             if self.second == 0:
...                     return 0
...             else:
...                     return self.first / self.second

>>> a = safeFourCal(4,0)
>>> a.div()
0



-클래스 변수
클래스변수는 값을 공유한다.
객체변수는 독립적으로 그 값을 유지.


>>> class Family:
...     lastname = "kim"
...
>>> print(Family.lastname) # 클래스이름.클래스변수 형태로 사용한다.
kim

>>> a = Family()
>>> b = Family()
>>> print(a.lastname)
kim
>>> print(b.lastname)
kim

#클래스 변수의 값을 바꾸었을 경우
>>> Family.lastname="Park"
>>> print(a.lastname)
Park
>>> print(b.lastname)
Park
# a. b 객체에 있는 클래스변수의 값이 모두 바뀐다.


[5-2] 모듈
모듈은 변수 또는 클래스를 모아놓은 파일. 
다른 사람이 미리 만들어놓은 파일을 사용하여 크로그래밍을 수월하게 할 수 있다.


-모듈 만들기
파이썬 확장자 .py로 만든 파이썬 파일은 모두 모듈
mod1.py를 저장했다.


-모듈 불러오기
** 1. import 모듈이름 **
** 2. 때로는 from 모듈이름 import 모듈함수 **
#cmd 이용


1.
C:\doit>python
Python 3.9.7 (tags/v3.9.7:1016ef3, Aug 30 2021, 20:19:38) [MSC v.1929 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import mod1
>>> print(mod1.add(3,4))
7
>>> print(mod1.sub(4,2))
2

2.
>>> from mod1 import *
>>> from mod1 import sub, add
>>> from mod1 import add



- if __name__ == "__main__": 의 의미

파이썬의 __name__ 변수.
직접 mod1.py 파일을 실행할 때: __name__ 변수에는 __main__이 저장됨.
파이썬 셸이나 다른 파이썬 모듈에서 mod1을 import 하면 
__name__ 변수에는 mod1이 저장됨.
>>> import mod1
>>> mod1.__name__
'mod1'


def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

if __name__ == "__main__": 
    print(add(1, 4))
    print(sub(4, 2))


-클래스나 변수 등을 포함한 모듈

#mod2.py
PI = 3.141592 #변수 포함 

class Math: #클래스 포함
    def solv(self, r):
        return PI * (r ** 2)

def add(a,b): #함수 포함
    return a+b

#cmd
>>> import mod2 
>>> print(mod2.PI) #모듈의 변수값을 사용
3.141592
>>> a = mod2.Math() #모듈의 클래스를 사용
>>> print(a.solv(2)) # 클래스 내 함수 사용
12.566368
>>> print(mod2.add(mod2.PI, 4.4)) #모듈의 함수를 이용.  
7.5415920000000005 # 모듈의 변수값과 실수를 더한다.


-다른 파일에서 모듈 불러오기

동일한 디렉터리에 있는 모듈을 불러와서 사용
# modest.py

import mod2
result = mod2.add(3,4)
print(result)




[5-3] 패키지

패키지는 파이썬 모듈을 계층적으로 관리할 수 있게 한다.
루트 디렉터리 아래에는 서브디렉터리가 있고,
.py가 확장자인 파일은 파이썬 모듈이다.


-패키지 만들기
#import 뒤에 적힌 경로를 모두 거친 후 함수에 도달할 수 있다.
#from을 적으면 from 뒤에 있는 경로는 생략 가능

1. echo 모듈을 import -> echo.py 파일
>>> import game.sound.echo
>>> game.sound.echo.echo_test()
echo

2. echo 모듈이 있는 디렉터리까지 import
>>> from game.sound import echo
>>> echo.echo_test()
echo

3. echo 모듈의 echo_test 함수를 직접 import
>>> from game.sound.echo import echo_test
>>> echo_test()
echo

**불가능

import game
이렇게 지정하면 game 디렉터리의 __init__.py에 정의한 것만 참조가능.

import game.sound.echo.echo_test
도트 연산자(.)를 사용할 때 가장 마지막 항목은 반드시 모듈 또는 패키지여야 한다.


-__init__.py의 용도
__init__.py 파일은 해당 디렉터리가 패키지의 일부임을 알려준다.
즉, 폴더 안에 이 파일이 있어야 패키지로 인식된다.

#이런 코드가 실행되려면 sound 폴더에 __init__.py 파일이 있어야함.
>>> from game.sound import * #from game.sound <- sound가 모듈이어야 함
>>> echo.echo_test()
echo


-relative 패키지

1. # render.py
from game.sound.echo import echo_test
def render_test():
    print("render")
    echo_test()

2.
# render.py
from ..sound.echo import echo_test #..은 부모 디렉터리를 의미

def render_test():
    print("render")
    echo_test()

#.은 현재 디렉터리를 의미

#cmd 실행
>>> from game.graphic.render import render_test
>>> render_test()
render
echo



[5-4] 예외처리