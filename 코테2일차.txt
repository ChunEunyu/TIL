[복잡도]
예. 배열의 합을 두 번 구하기
알고리즘의 연산 시간은 기본 연산의 실행 횟수로 평가.
복잡도라는 개념을 사용.

시간복잡도: 연산의 횟수(요즘은 더 중요)
공간복잡도: 자원 공간의 양.

[시간복잡도]
최악, 최선, 중간의 경우로 나누어 평가.

Big-O 표기법, O(n): 최악의 경우를 대비하는 표기법.
최소한의 성능을 보장함. 가장 많이 사용.
Big-Ω 표기법, Ω(n): 최상의 실행시간.
Big-θ 표기법, θ(n): 알고리즘 평균 실행시간을 표기.

[Big-O 표기법]
1. O(1), 상수 시간
입력된 데이터의 크기와 상관없이 일정한 시간이 소요되는 알고리즘.
데이터가 얼마나 많이 들어오는지에 관계없이 첫 요소만 출력한다.
def first_element(arr):
    print(f"배열의 첫 요소는 {arr[0]} 입니다.")

2. O(n), 선형 시간
입력된 데이터의 크기에 비례해서 처리시간이 늘어난다.
배열의 모든 요소에 접근하기 때문에 배열 크기에 정비례해서 실행시간이 늘어남.
def first_element(arr):
    for i in range(len(arr)):
        item = arr[i]
        print(f"배열의 {i}번째 요소는 {item} 입니다.")

3.  O(2^n) , 지수 시간
입력된 데이터 크기의 지수 제곱에 비례해서 처리시간이 늘어난다.
재귀함수로 구현한 피보나치 수열.
피보나치 수열은 입력의 크기가 1 증가할 때마다 실행 시간이 약 두 배로 증가.
def fibonacci(num):
	if (num <= 1):
		return num;
	return fibonacci(num - 2) + fibonacci(num - 1); 

4. 종합
로그시간, 다항 로그 시간, 2차 시간

[1일차 예제의 빅오 표기법]
빅오표기법은 상수항을 무시한다.
데이터의 입력 개수가 충분히 크다고 가정. 
상수항 정도의 차이는 무시. 가장 단순한 형태로 표기.


[공간복잡도]
고정 공간: 코드가 저장되고, 단순한 변수&상수가 저장되는 공간.
가변 공간: 코드 실행 도중 동적으로 필요한 공간. 알고리즘과 연결됨.
